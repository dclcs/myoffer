## Q1: c++static关键字

- 静态成员变量：在类内成员变量的声明前加上关键字`static`，该数据成员就是类内的静态数据成员。

    - 静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。
    - 因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。
    - 静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。
    - static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
    - 静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
    - 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞
    - 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。
    - 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
    - 如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
    - sizeof 运算符不会计算 静态成员变量。

-  静态成员函数

  - 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。
  - 出现在类体外的函数定义不能指定关键字static；
  - 静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；
  - 静态成员函数不能访问非静态成员函数和非静态成员变量；
  - 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
  - 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；
  - 调用静态成员函数，两种方式：

  - 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。
  - 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。

- 静态全局变量

  - 该变量在全局数据区分配内存；
  - 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；
  - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 　
  - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。
- 静态局部变量

  - 静态局部变量在全局数据区分配内存；
  - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
  - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
  - 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束
- 静态函数

  - 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

## Q2: 封装，继承，多态

- 封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

- 继承：根据另一个类来定义一个类。`is a`

  - 派生类可以访问基类中的非私有成员

     |   访问   | public | protected | private |
     | :------: | ------ | --------- | ------- |
     | 同一个类 | yes    | yes       | yes     |
     |  派生类  | yes    | yes       | no      |
     | 外部的类 | yes    | no        | no      |

  - 继承类型：
    - public 继承： 当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但可以通过调用基类的公有和保护成员来访问
    - protected 继承：当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员
    - private 继承：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员
  - 多重继承
    
    - 多重继承： 一个子类可以由多个父类

- 多态：通过基类访问派生类定义的函数。多态性使得程序调用的函数实在运行时动态确定的，而不是编译时静态确定的。”一个接口，多种方法“

  - 多态的目的：相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作
  - C++ 支持两种多态性
    - 编译时多态性（静态）： 通过重载函数实现： 先期联编 early binding
      - 编译器编译期间可以确定函数调用的地址
    - 运行时多态性（动态）： 通过虚函数实现
      - 子类重新定义弗雷的做法称为覆盖（Override）



## Q3: 虚函数

- 虚函数： 在类成员方法的声明语句前加 `virtual`, `virtual void func()`
  - 子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写（Override）
  - 当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定
  - 通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用
  - 虚函数指针和虚函数表
    - C++中虚函数使用虚函数表和 虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地 址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的 虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。
- 纯虚函数：在虚函数后加 `=0` 如 `virtual void func() = 0`
  - 子类必须提供虚函数的个性化实现
  - 含有纯虚函数的类称之为抽象类， 不能生成对象，只能创建它的派生类的实例
- 构造函数不能时虚函数， 析构函数可以时虚函数且最好设置为虚函数
  - 纯虚函数通常没有定义体， 但也完全可以哟个有
  - 析构函数可以时纯虚的， **但纯虚析构函数必须由定义体**，因为析构函数的调用是在子类中隐含的
  - 非纯的虚函数必须有定义体，不然是个错误



## Q4. 智能指针 Ref: [LINK](https://www.jianshu.com/p/e4919f1c3a28)

 - `auto_ptr`, `shared_ptr`, `weak_ptr`, `unique_ptr`
 - 智能指针式一个`RAII`类模型，用来动态的分配内存。
 - `auto_ptr` ： C++ 98
   	- 当把一个`auto_ptr`赋值个另外一个`auto_ptr`时，他的所有权也转移了
      	- `auto_ptr`不能指向一组对象
      	- `auto_ptr`不能和标准容器一起使用
 - `shared_ptr` ：共享所有权(`sharedownership`), 多个指针可以同时指向一个对象，当最后一个`shared_ptr`离开作用域时，内存才会自动释放。
    - #TODO 实现; `share_ptr`线程安全。
    - 如果几个`shared_ptrs`指向的内存块属于不同组，将产生错误。
   - 如果从一个普通指针创建一个`shared_ptr`还会引发另外一个问题。在上面的代码中，考虑到只有一个`shared_ptr`是由`p`创建的，代码可以好好工作。万一程序员在智能指针作用域结束之前删除了普通指针`p`。天啦噜！！！又是一个crash。
   - 循环引用：如果共享智能指针卷入了循环引用，资源都不会正常释放。
- `weak_ptr` ：拥有共享语义和不包含语义。
- `unique_ptr` #TODO



## Q5: c++类型转换，用过哪些，静态转换能转换空指针吗 【^^^】
- 四种类型强制转换
  - const_cast
    - 常量指针被转化成非常量的指针，并且仍然指向原来的对象； 
    - 常量引用被转换成非常量的引用，并且仍然指向原来的对象； 
    - const_cast一般用于修改指针。如const char *p形式。
  - static_cast
    - static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。
    - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
    - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。
    - static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)
    - 在c++ primer 中说道：c++ 的任何的隐式转换都是使用 static_cast 来实现。
  - dynamic_cast
    - dynamic_cast强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.
    - 对于从子类到基类的指针转换 ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果。而从基类到子类的转换 , dynamic_cast 在转换时也没有报错,但是输出给 base2sub 是一个 nullptr ,说明dynami_cast 在程序运行时对类型转换对“运行期类型信息”（Runtime type information，RTTI）进行了检查. 这个检查主要来自虚函数(virtual function) 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数
  - reinterpret_cast
    - reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！ 


## Q6: 介绍shared ptr和unique ptr以及适用场景。shared ptr是线程安全的吗？为什么不安全？那在多线程中使用shared ptr需要都加锁吗？


## Q7: 深拷贝和浅拷贝分别是什么？std move是什么作用？移动拷贝函数呢？move过后的class还能用吗，用起来会有问题吗？
- 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象


## Q8: extern在c和c++中的作用？如何使用？extern c在c++中的原理？
- 在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。
  - 在其他文件中要使用它们， 可以有两种方式：
    - 使用头文件，然后声明它们，然后其他文件去包含头文件
    - 在其他文件中直接extern
- `extern c`
  - C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

## Q9 : 左值引用和右值引用的区别?
- 左值引用
  - 左值引用在汇编层面其实和普通的指针是一样的；定义引用变量必须初始化，因为引用其实就是一个别名，需要告诉编译器定义的是谁的引用。

  - 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。
- 右值引用
  - 可以取地址的，有名字的，非临时的就是左值；
  - 不能取地址的，没有名字的，临时的就是右值
  - 类型 && 引用名 = 右值表达式;
  - 在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。
- [LINK](https://zhuanlan.zhihu.com/p/97128024)


## Q10 : 引用和指针的区别?
- 指针和引用的定义和性质区别：
  - 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
  - 引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。
  - 可以有const指针，但是没有const引用；
  - 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
  - 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
  - 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
  - “sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；
  - 指针和引用的自增(++)运算意义不一样；
  - 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；
- 指针和引用作为函数参数进行传递时的区别
  - 指针作为参数进行传递：也是将实参的一个拷贝传递给形参
  - 将引用作为函数的参数进行传递。实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间
## Q11: c++传值参数和传引用参数

- 传值参数

  - 普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值


- 指针形参

  - 函数的形参可以是指针，此时将复制实参指针。与其他非引用类型的形参一样，该类形参的任何改变也仅作用于局部副本。如果函数将新指针赋给形参，主调函数使用的实参指针的值没有改变。事实上被复制的指针只影响对指针的赋值。如果函数形参是非 const 类型的指针，则函数可通过指针实现赋值

- 值传递的局限性

  - 值传递并不是在所有的情况下都适合，不适宜值传递的情况包括：
    - 当需要在函数中修改实参的值时。
    - 当需要以大型对象作为实参传递时。对实际的应用而言，复制对象所付出的时间和存储空间代价往往过在。
    - 当没有办法实现对象的值传递时。
- 传引用参数

  - 引用形参直接关联到其所绑定的对象，而并非这些对象的副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。
  - 引用形参的另一种用法是向主调函数返回额外的结果。函数只能返回单个值，但有些时候，函数有不止一个的内容需要返回。

- 利用引用避免复制

  - 在向函数传递大型对象时，需要使用引用形参，这是引用形参适用的另一种情况。虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题，但是对于大部分的类类型或者大型数组，它的效率（通常）太低了；使用引用形参，函数可以直接访问实参对象，而无须复制它。

## Q12: 为什么传类对象时候一般要传常量引用
对于的普通形参，拷贝大的类对象或者容器对象比较低效，甚至有的类类型根本不支持拷贝操作。
- 普通引用 
（1）容易让人误解此变量可以修改。 
（2）不能把const常量、字面值和需要转换的对象传给普通引用。
- 常量引用避免上述所有的问题，引用只是变量的别名，不存在拷贝。同时常量引用又无法修改变量的值。

## Q13: 在传参数用引用的时候可能会发生什么错误
如果实参与引用参数不匹配，C++将生成临时变量。如果引用参数是const,则编译器在下面两种情况下生成临时变量：

- 实参类型是正确的，但不是左值

- 实参类型不正确，但可以转换为正确的类型
## Q14: c++预处理阶段的作用 四个阶段要背熟啊
- 预处理、编译、汇编、链接。预处理就是本文要详细说的宏替换、头文件包含等；编译是指对预处理后的代码进行语法和语义分析，最终得到汇编代码或接近汇编的其他中间代码；汇编是指将上一步得到的汇编或中间代码转换为目标机器的二进制指令，一般是每个源文件生成一个二进制文件（VS是.obj，GCC是.o）；链接是对上一步得到的多个二进制文件“链接”成可执行文件或库文件等。

  - 字符映射（Trigraph replacement）：将系统相关的字符映射到C++标准定义的相应字符，但语义不变，如对不同操作系统上的不同的换行符统一换成规定字符（设为newline）；
  - 续行符处理（Line splicing）：对于“\”紧跟newline的，删去“\”和newline（我们在#define等中用的续行在Preprocessor之前就处理了），该过程只进行1遍（如果是“\\”后有两个换行只会删去一个“\”）；
  - 字串分割（Tokenization）：源代码作为一个串被分为如下串（Token）的连接：注释、whitespace、preprocessing tokens（标示符等这时都是preprocessing tokens，因为此时不知道谁是标示符，经过下一步之后，真正的预处理符会被处理）；
  - 执行Preprocessor：对#include指令做递归进行该1-4步，此步骤时候源代码中不再含有任何预处理语句（#开头的哪些）。


## Q15: 局部变量和new对象的区别
1.new出来的对象在堆内存中；局部变量是跟着方法走的，在栈内存中

2.new出来的对象会在内存中持续存在，直到垃圾回收消失；局部变量在方法结束后，立刻出栈，消失


## Q16: c++创始者为什么要设置友元函数 怎么设置friend
友元能够使得普通函数直接访问类的保护数据，避免了类成员函数的频繁调用，可以节约处理器开销，提高程序的效率，但矛盾的是，即使是最大限度的保护，同样也破坏了类的封装特性，这即是友元的缺点，

## Q17: c++类中的访问权限

## Q18: C++的inline函数机制，跟宏函数的区别

内联（inline）函数

通过inline关键字将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开(将函数体有关代码嵌入到调用处)。

共同点： 

使用宏和内联函数都可以节省在函数调用方面所带来的时间和空间开销。二者都采用了空间换时间的方式，在其调用处进行展开；

内联函数和带参数的宏定义实现的功能是一样的。

区别：

(1)  在预编译时期，宏定义在调用处执行字符串的原样替换(宏展开)。在编译时期，内联函数在调用处展开，同时进行参数类型检查，宏定义不会进行参数类型检查。

(2)  内联函数首先是函数，可以像调用普通函数一样调用内联函数。而宏定义往往需要添加很多括号防止歧义，编写更加复杂。
(3)  内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了(无法将this指针放在合适位置)。

可以用内联函数完全替代宏。

在编写内联函数时，函数体应该短小而简洁，不应该包含循环等较复杂结构，否则编译器不会将其当作内联函数看待，而是把它决议成为一个静态函数。

有些编译器甚至会优化内联函数，通常为避免一些不必要拷贝和构造，提高工作效率。


## Q19: new malloc 区别

其实在使用的大部分场景下，两者是可以通用的，但是我们还是要知道他两的区别。

1、malloc与free是c++/c语言的标准函数，new/delete是C++的运算符。

2、他们都可用于申请动态内存和释放内存。new/delete比malloc/free更加智能，其实底层也是执行的malloc/free。为啥说new/delete更加的智能？因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。

3、new返回指定类型的指针，并且可以自动计算出所需要的大小

malloc必须用户指定大小，并且默然返回类型为void*,必须强行转换为实际类型的指针


## Q20 : 值传递和指针传递

## Q21: 结构体传参会发生什么
结构体变量可以作为函数的参数和返回值。作为函数的实参时，可以实现函数的传值调用。当使用结构体变量作为函数的形参时，实参也应该是结构体变量名以实现传值调用，实参将拷贝副本给形参，在被调用函数中改变形参值对于调用函数中的实参没有影响。
## Q22: vector底层原理

## Q23: 纯虚函数有三个，实例化的时候实现几个？两个可以吗？

## Q24: 结构体和类成员关键字的区别
一、相同之处：结构体中可以包含函数；也可以定义public、private、protected数据成员；定义了结构体之后，可以用结构体名来创建对象。但C中的结构体不允许有函数；
也就是说在C++当中，结构体中可以有成员变量，可以有成员函数，可以从别的类继承，也可以被别的类继承，可以有虚函数。
二、不同之处：结构体定义中默认情况下的成员是public，而类定义中的默认情况下的成员是private的。类中的非static成员函数有this指针，（而struct中没有是错误的，一直被误导啊，经过测试struct的成员函数一样具有this指针），类的关键字class能作为template模板的关键字 即template class A{}; 而struct不可以。
实际上，C中的结构体只涉及到数据结构，而不涉及到算法，也就是说在C中数据结构和算法是分离的，而到C++中一类或者一个结构体可以包含函数（这个函数在C++我们通常中称为成员函数），C++中的结构体和类体现了数据结构和算法的结合。

## Q25: vector扩容原理;vector<int*> temp(10)，vector大小;vector clear()函数可以释放内存吗？vector的resize和reserve那怎么释放vector内存？

## Q26: C++序列化

## Q27: RAII
RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

## Q28: 野指针
造成野指针的常见原因有三种：

        1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针。在Debug模式下，VC++编译器会把未初始化的栈内存上的指针全部填成 0xcccccccc ，当字符串看就是 “烫烫烫烫……”；会把未初始化的堆内存上的指针全部填成 0xcdcdcdcd，当字符串看就是 “屯屯屯屯……”。把未初始化的指针自动初始化为0xcccccccc或0xcdcdcdcd，而不是就让取随机值，那是为了方便我们调试程序，使我们能够一眼就能确定我们使用了未初始化的野指针。在Release模式下，编译器则会将指针赋随机值，它会乱指一气。所以，指针变量在创建时应当被初始化，要么将其设置为NULL，要么让它指向合法的内存。

        2、指针指向的内存被释放了，而指针本身没有置NULL。对于堆内存操作，我们分配了一些空间（使用malloc函数、calloc函数或new操作符），使用完后释放（使用free函数或delete操作符）。指针指向的内存被释放了，而指针本身没有置NULL。通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用。因为即便p不是NULL指针，它也不指向合法的内存块。所以在指针指向的内存被释放后，应该将指针置为NULL。

        3 、指针超过了变量的作用范围。即在变量的作用范围之外使用了指向变量地址的指针。这一般发生在将调用函数中的局部变量的地址传出来引起的。这点容易被忽略，虽然代码是很可能可以执行无误，然而却是极其危险的。局部变量的作用范围虽然已经结束，内存已经被释放，然而地址值仍是可用的，不过随时都可能被内存管理分配给其他变量

## Q29: 内存泄漏情况，怎么处理

## Q30: cpp中队列有哪些，priority_queue底层实现 ，使用场景

## Q31: map umap 数据结构， 怎么实现线程安全map （还问了java分段锁，感觉部门是做java的（明明投的是c++））
map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。哈希表详细介绍

map：

优点：

有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间

适用处：对于那些有顺序要求的问题，用map会更高效一些

unordered_map：

优点： 因为内部实现了哈希表，因此其查找速度非常的快
缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map

## Q32: rehash的过程， rehash的过程中新插入的数据怎么处理
C++的hash表中有一个负载因子loadFactor，当loadFactor<=1时，hash表查找的期望复杂度为O(1).
 因此，每次往hash表中添加元素时，我们必须保证是在loadFactor <1的情况下，才能够添加。
 
因此，当Hash表中loadFactor==1时，Hash就需要进行rehash。rehash过程中，会模仿C++的vector
扩容方式，Hash表中每次发现loadFactor ==1时，就开辟一个原来桶数组的两倍空间，称为新桶数组
，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。

## Q33: 构造函数可以调用虚函数吗?拷贝构造为什么参数需要传引用?
可以，但最好不要这样用
在构造函数中调用虚成员函数，虽然这是个不很常用的技术，但研究一下可以加深对虚函数机制及对象构造过程的理解。这个问题也和一般直观上的认识有所差异。先看看下面的两个类定义。
struct C180 {
C180() { foo(); this->foo(); }
virtual foo() {
cout << &quot;<< C180.foo this: &quot; << this << &quot; vtadr: &quot; << *(void**)this << endl; } };
struct C190 : public C180 {
C190() {}
virtual foo() {
cout << &quot;<< C190.foo this: &quot; << this << &quot; vtadr: &quot; << *(void**)this << endl; } };
父类中有一个虚函数，并且父类在它的构造函数中调用了这个虚函数，调用时它采用了两种方法一种是直接调用，一种是通过this指针调用。同时子类又重写了这个虚函数。
我们可以来预测一下如果构造一个C190的对象会发生什么情况。
我们知道，在构造一个对象时，过程是这样的：
1) 首先会按对象的大小得到一块内存(在heap上或在stack上)，
2) 把指向这块内存的指针做为this指针来调用类的构造函数，对这块内存进行初始化。
3) 如果对象有父类就会先调用父类的构造函数(并依次递归)，如果有多个父类(多重继承)会依次对父类的构造函数进行调用，并会适当的调整this指针的位置。在调用完所有的父类的构造函数后，再执行自己的代码。
照上面的分析构造C190时也会调用C180的构造函数，这时在C180构造函数中的第一个foo调用为静态绑定，会调用到C180::foo()函数。第二个foo调用是通过指针调用的，这时多态行为会发生，应该调用的是C190::foo()函数。


所以绕了那么大的弯子，就是想说明拷贝构造函数的参数使用引用类型不是为了减少一次内存拷贝， 而是避免拷贝构造函数无限制的递归下去。


## Q34: 让你设计多少倍扩容 考虑哪些因素

实现大整型类型所有可能的接口（写了拷贝构造函数，赋值函数和重载运算符，当时不是很记得什么需要写成成员函数，什么写成友元函数了）；

；。

C++的新的特性 move函数具体是干嘛的

C++的析构函数为什么要加上virtual

基类的指针指向派生类需要注意什么

C++文件生成可执行文件的过程

静态链接和动态链接的区别


new 执行过程中发生了啥

C++的虚函数机制


C++的inline函数机制，跟宏函数的区别


new malloc 区别
• 值传递和指针传递
• 指针和引用的区别
• c++11新特性
• 说一下智能指针
• 左值引用和右值引用
• 结构体传参会发生什么
• vector底层原理
• 深拷贝和浅拷贝
• 构造函数的几种方法