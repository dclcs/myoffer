#### Q1: c++static关键字

- 静态成员变量：在类内成员变量的声明前加上关键字`static`，该数据成员就是类内的静态数据成员。

    - 静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。
    - 因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。
    - 静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。
    - static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
    - 静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
    - 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞
    - 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。
    - 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
    - 如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
    - sizeof 运算符不会计算 静态成员变量。

-  静态成员函数

  - 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。
  - 出现在类体外的函数定义不能指定关键字static；
  - 静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；
  - 静态成员函数不能访问非静态成员函数和非静态成员变量；
  - 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
  - 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；
  - 调用静态成员函数，两种方式：

  - 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。
  - 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。

- 静态全局变量

  - 该变量在全局数据区分配内存；
  - 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；
  - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 　
  - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。
- 静态局部变量

  - 静态局部变量在全局数据区分配内存；
  - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
  - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
  - 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束
- 静态函数

  - 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

#### Q2: 封装，继承，多态

- 封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

- 继承：根据另一个类来定义一个类。`is a`

  - 派生类可以访问基类中的非私有成员

     |   访问   | public | protected | private |
     | :------: | ------ | --------- | ------- |
     | 同一个类 | yes    | yes       | yes     |
     |  派生类  | yes    | yes       | no      |
     | 外部的类 | yes    | no        | no      |

  - 继承类型：
    - public 继承： 当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但可以通过调用基类的公有和保护成员来访问
    - protected 继承：当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员
    - private 继承：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员
  - 多重继承
    
    - 多重继承： 一个子类可以由多个父类

- 多态：通过基类访问派生类定义的函数。多态性使得程序调用的函数实在运行时动态确定的，而不是编译时静态确定的。”一个接口，多种方法“

  - 多态的目的：相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作
  - C++ 支持两种多态性
    - 编译时多态性（静态）： 通过重载函数实现： 先期联编 early binding
      - 编译器编译期间可以确定函数调用的地址
    - 运行时多态性（动态）： 通过虚函数实现
      - 子类重新定义弗雷的做法称为覆盖（Override）



#### Q3: 虚函数

- 虚函数： 在类成员方法的声明语句前加 `virtual`, `virtual void func()`
  - 子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写（Override）
  - 当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定
  - 通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用
  - 虚函数指针和虚函数表
    - C++中虚函数使用虚函数表和 虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地 址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的 虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。
- 纯虚函数：在虚函数后加 `=0` 如 `virtual void func() = 0`
  - 子类必须提供虚函数的个性化实现
  - 含有纯虚函数的类称之为抽象类， 不能生成对象，只能创建它的派生类的实例
- 构造函数不能时虚函数， 析构函数可以时虚函数且最好设置为虚函数
  - 纯虚函数通常没有定义体， 但也完全可以哟个有
  - 析构函数可以时纯虚的， **但纯虚析构函数必须由定义体**，因为析构函数的调用是在子类中隐含的
  - 非纯的虚函数必须有定义体，不然是个错误



#### Q4. 智能指针 Ref: [LINK](https://www.jianshu.com/p/e4919f1c3a28)

 - `auto_ptr`, `shared_ptr`, `weak_ptr`, `unique_ptr`
 - 智能指针式一个`RAII`类模型，用来动态的分配内存。
 - `auto_ptr` ： C++ 98
   	- 当把一个`auto_ptr`赋值个另外一个`auto_ptr`时，他的所有权也转移了
      	- `auto_ptr`不能指向一组对象
      	- `auto_ptr`不能和标准容器一起使用
 - `shared_ptr` ：共享所有权(`sharedownership`), 多个指针可以同时指向一个对象，当最后一个`shared_ptr`离开作用域时，内存才会自动释放。
    - #TODO 实现; `share_ptr`线程安全。
    - 如果几个`shared_ptrs`指向的内存块属于不同组，将产生错误。
   - 如果从一个普通指针创建一个`shared_ptr`还会引发另外一个问题。在上面的代码中，考虑到只有一个`shared_ptr`是由`p`创建的，代码可以好好工作。万一程序员在智能指针作用域结束之前删除了普通指针`p`。天啦噜！！！又是一个crash。
   - 循环引用：如果共享智能指针卷入了循环引用，资源都不会正常释放。
- `weak_ptr` ：拥有共享语义和不包含语义。
- `unique_ptr` #TODO



#### Q5: c++类型转换，用过哪些，静态转换能转换空指针吗 【^^^】
- 四种类型强制转换
  - const_cast
    - 常量指针被转化成非常量的指针，并且仍然指向原来的对象； 
    - 常量引用被转换成非常量的引用，并且仍然指向原来的对象； 
    - const_cast一般用于修改指针。如const char *p形式。
  - static_cast
    - static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。
    - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
    - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。
    - static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)
    - 在c++ primer 中说道：c++ 的任何的隐式转换都是使用 static_cast 来实现。
  - dynamic_cast
    - dynamic_cast强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.
    - 对于从子类到基类的指针转换 ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果。而从基类到子类的转换 , dynamic_cast 在转换时也没有报错,但是输出给 base2sub 是一个 nullptr ,说明dynami_cast 在程序运行时对类型转换对“运行期类型信息”（Runtime type information，RTTI）进行了检查. 这个检查主要来自虚函数(virtual function) 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数
  - reinterpret_cast
    - reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！ 


#### Q6: 介绍shared ptr和unique ptr以及适用场景。shared ptr是线程安全的吗？为什么不安全？那在多线程中使用shared ptr需要都加锁吗？


#### Q7: 深拷贝和浅拷贝分别是什么？std move是什么作用？移动拷贝函数呢？move过后的class还能用吗，用起来会有问题吗？
- 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。
- 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象


#### Q8: extern在c和c++中的作用？如何使用？extern c在c++中的原理？
- 在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。
  - 在其他文件中要使用它们， 可以有两种方式：
    - 使用头文件，然后声明它们，然后其他文件去包含头文件
    - 在其他文件中直接extern
- `extern c`
  - C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

#### Q9 : 左值引用和右值引用的区别?

#### Q10 : 引用和指针的区别?

#### Q11: c++传值参数和传引用参数


#### Q12: 为什么传类对象时候一般要传常量引用

#### Q13: 在传参数用引用的时候可能会发生什么错误


#### Q14: c++预处理阶段的作用 四个阶段要背熟啊


#### Q15: 局部变量和new对象的区别


#### Q16: c++创始者为什么要设置友元函数 怎么设置friend

#### Q17: c++类中的访问权限

#### Q18: C++的inline函数机制，跟宏函数的区别

#### Q19: new malloc 区别
#### Q20 : 值传递和指针传递

#### Q21: 结构体传参会发生什么

#### Q22: vector底层原理

#### Q23: 纯虚函数有三个，实例化的时候实现几个？两个可以吗？

#### Q24: 结构体和类成员关键字的区别

#### Q25: vector扩容原理;vector<int*> temp(10)，vector大小;vector clear()函数可以释放内存吗？vector的resize和reserve那怎么释放vector内存？

#### Q26: C++序列化

#### Q27: RAII

#### Q28: 野指针

#### Q29: 内存泄漏情况，怎么处理

#### Q30: cpp中队列有哪些，priority_queue底层实现 ，使用场景

#### Q31: map umap 数据结构， 怎么实现线程安全map （还问了java分段锁，感觉部门是做java的（明明投的是c++））

#### Q32: rehash的过程， rehash的过程中新插入的数据怎么处理

#### Q33: 构造函数可以调用虚函数吗?拷贝构造为什么参数需要传引用?
#### Q34: 让你设计多少倍扩容 考虑哪些因素

实现大整型类型所有可能的接口（写了拷贝构造函数，赋值函数和重载运算符，当时不是很记得什么需要写成成员函数，什么写成友元函数了）；

；。

C++的新的特性 move函数具体是干嘛的

C++的析构函数为什么要加上virtual

基类的指针指向派生类需要注意什么

C++文件生成可执行文件的过程

静态链接和动态链接的区别


new 执行过程中发生了啥

C++的虚函数机制


C++的inline函数机制，跟宏函数的区别


new malloc 区别
• 值传递和指针传递
• 指针和引用的区别
• c++11新特性
• 说一下智能指针
• 左值引用和右值引用
• 结构体传参会发生什么
• vector底层原理
• 深拷贝和浅拷贝
• 构造函数的几种方法