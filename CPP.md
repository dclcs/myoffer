#### Q1: c++static关键字

- 静态成员变量：在类内成员变量的声明前加上关键字`static`，该数据成员就是类内的静态数据成员。

    - 静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。
    - 因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。
    - 静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。
    - static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
    - 静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
    - 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞
    - 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。
    - 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
    - 如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
    - sizeof 运算符不会计算 静态成员变量。

-  静态成员函数

  - 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。
  - 出现在类体外的函数定义不能指定关键字static；
  - 静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；
  - 静态成员函数不能访问非静态成员函数和非静态成员变量；
  - 非静态成员函数可以任意地访问静态成员函数和静态数据成员；
  - 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；
  - 调用静态成员函数，两种方式：

  - 通过成员访问操作符(.)和(->)，也即通过类对象或指向类对象的指针调用静态成员函数。
  - 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。

- 静态全局变量

  - 该变量在全局数据区分配内存；
  - 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；
  - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 　
  - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。
- 静态局部变量

  - 静态局部变量在全局数据区分配内存；
  - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
  - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
  - 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束
- 静态函数

  - 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

#### Q2: 封装，继承，多态

- 封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

- 继承：根据另一个类来定义一个类。`is a`

  - 派生类可以访问基类中的非私有成员

     |   访问   | public | protected | private |
     | :------: | ------ | --------- | ------- |
     | 同一个类 | yes    | yes       | yes     |
     |  派生类  | yes    | yes       | no      |
     | 外部的类 | yes    | no        | no      |

  - 继承类型：
    - public 继承： 当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但可以通过调用基类的公有和保护成员来访问
    - protected 继承：当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员
    - private 继承：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员
  - 多重继承
    
    - 多重继承： 一个子类可以由多个父类

- 多态：通过基类访问派生类定义的函数。多态性使得程序调用的函数实在运行时动态确定的，而不是编译时静态确定的。”一个接口，多种方法“

  - 多态的目的：相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作
  - C++ 支持两种多态性
    - 编译时多态性（静态）： 通过重载函数实现： 先期联编 early binding
      - 编译器编译期间可以确定函数调用的地址
    - 运行时多态性（动态）： 通过虚函数实现
      - 子类重新定义弗雷的做法称为覆盖（Override）



#### Q3: 虚函数

- 虚函数： 在类成员方法的声明语句前加 `virtual`, `virtual void func()`
  - 子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写（Override）
  - 当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定
  - 通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用
  - 虚函数指针和虚函数表
    - C++中虚函数使用虚函数表和 虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地 址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的 虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。
- 纯虚函数：在虚函数后加 `=0` 如 `virtual void func() = 0`
  - 子类必须提供虚函数的个性化实现
  - 含有纯虚函数的类称之为抽象类， 不能生成对象，只能创建它的派生类的实例
- 构造函数不能时虚函数， 析构函数可以时虚函数且最好设置为虚函数
  - 纯虚函数通常没有定义体， 但也完全可以哟个有
  - 析构函数可以时纯虚的， **但纯虚析构函数必须由定义体**，因为析构函数的调用是在子类中隐含的
  - 非纯的虚函数必须有定义体，不然是个错误



#### Q4. 智能指针 Ref: [LINK](https://www.jianshu.com/p/e4919f1c3a28)

 - `auto_ptr`, `shared_ptr`, `weak_ptr`, `unique_ptr`
 - 智能指针式一个`RAII`类模型，用来动态的分配内存。
 - `auto_ptr` ： C++ 98
   	- 当把一个`auto_ptr`赋值个另外一个`auto_ptr`时，他的所有权也转移了
      	- `auto_ptr`不能指向一组对象
      	- `auto_ptr`不能和标准容器一起使用
 - `shared_ptr` ：共享所有权(`sharedownership`), 多个指针可以同时指向一个对象，当最后一个`shared_ptr`离开作用域时，内存才会自动释放。
    - #TODO 实现; `share_ptr`线程安全。
    - 如果几个`shared_ptrs`指向的内存块属于不同组，将产生错误。
   - 如果从一个普通指针创建一个`shared_ptr`还会引发另外一个问题。在上面的代码中，考虑到只有一个`shared_ptr`是由`p`创建的，代码可以好好工作。万一程序员在智能指针作用域结束之前删除了普通指针`p`。天啦噜！！！又是一个crash。
   - 循环引用：如果共享智能指针卷入了循环引用，资源都不会正常释放。
- `weak_ptr` ：拥有共享语义和不包含语义。
- `unique_ptr` #TODO





C++的新的特性 move函数具体是干嘛的

C++的析构函数为什么要加上virtual

基类的指针指向派生类需要注意什么



C++文件生成可执行文件的过程

静态链接和动态链接的区别

linux按下ctrl+c为什么会结束当前进程(不会)

new 执行过程中发生了啥