# Network

## Q1: OSI 和 TCP/IP 哪几层？每一层的作用？

- OSI
  - 物理层
  - 数据链路层
  - 传输层
  - 网络层
  - 会话层
  - 表示层
  - 应用层
- TCP/IP
  - 物理层
  - 网络接口层
  - 网络层
  - 传输层
  - 应用层

## Q2: TCP和UDP区别

- TCP面向连接的协议，收发数据之前要建立连接；UDP是一个非连接的协议，传输数据之前两端不用建立连接；
- TCP是可靠交付：无差错，不丢失，不重复，按序到达。UDP是尽最大努力交付，不保证可靠交付。
- TCP具有高可靠性，用==拥塞控制流量控制确保传输数据的正确性==；UDP在传输过程前不建立连接，不对数据报进行检查和修改；
- TCP对系统资源要求比较多；UDP对系统资源要求较少；
- UDP具有较好的实时性；工作效率比TCP高
- TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。
- TCP首部开销大，首部20个字节。UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）

## Q3: UDP相关

- UDP优化

## Q4: TCP相关

- 三次握手
  - A->B 发出请求连接数据包
    - Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
  - B->A 发出发送同意连接和要求同步
    - Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
  - A->B 发送一个数据报确认主机B要求同步
    - Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
- 四次握手
  - A->B 提出停止TCP连接请求
    - 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。
  - B->A 确认TCP即将关闭
    - .服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。
  - B->A 提出关闭请求
    - 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认
  - A->B 对请求进行确认呢
    - 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

![](img/tcp.png)

- TIME_WAIT和CLOSE_WAIT
  - 详细过程
    - 主动关闭连接的一方，调用close()；协议层发送FIN包 ;
    - 被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入==CLOSE_WAIT==状态，主动关闭的一方等待对方关闭，则进 入==FIN_WAIT_2==状态；此时，主动关闭的一方等待被动关闭一方的应用程序，调用close操作 ;
    - 被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入==LAST_ACK==状态；
    - 主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入==TIME_WAIT==状态；而被动关闭的一方，进入CLOSED状态 ;
    - 等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态 ; 
  - TIME_WAIT
    - TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接
    - 假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面 临重发最终ACK的情形。
    - 如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被 丢弃。建立第二个连接的时候，不会混淆。
  - CLOSE_WAIT
    - CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。

- 大量TIME_WAIT解决方案
  - 应用层面
　  - 尽量避免频繁关闭连接，如业务优化，或者使用长连接等；
  - 系统层面
    - 缩短MSL时间。
    - 增加可用端口数量。可用端口数量=单进程可打开的连接数量*机器数量。
  - MSL时间
　　RFC793定义MSL为2分钟。
    ```c++
    查看：sysctl -a | grep time | grep wait
    修改：

    vi /etc/sysctl.conf;
    net.ipv4.tcp_fin_timeout = 30;
    执行 /sbin/sysctl -p 让参数生效;
    ```
  - TIME_WAIT的重用和快速回收
    - 打开方式：设置TCP参数` net.ipv4.tcp_tw_reuse = 1` 和` net.ipv4.tcp_tw_recycle = 1；`注意：使用tcp_tw_reuse和tcp_tw_recycle解决TIME_WAIT过多问题是非常危险的，参考RFC
- CLOSE_WAIT

## Q5: 点击一个网址会发生什么？

- 首先将域名解析为IP（使用DNS协议）
- 建立连接（三次握手）
- 传输数据
- 断开连接（四次挥手）

## Q6: DNS协议

- 过程： 

<img src="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg" alt="img"  />

    ①本机向local dns请求www.baidu.com
    
    ②local dns向根域请求www.baidu.com，根域返回com.域的服务器IP
    
    ③向com.域请求www.baidu.com，com.域返回baidu.com域的服务器IP
    
    ④向baidu.com请求www.baidu.com，返回cname www.a.shifen.com和a.shifen.com域的服务器IP
    
    ⑤向root域请求www.a.shifen.com
    
    ⑥向com.域请求www.a.shife.com
    
    ⑦向shifen.com请求
    
    ⑧向a.shifen.com域请求
    
    ⑨拿到www.a.shifen.com的IP
    
    ⑩localdns返回本机www.baidu.com cname www.a.shifen.com 以及 www.a.shifen.com的IP


​    
​    
## Q7: https和http区别

- HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性

- HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥

- HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书

- HTTP协议端口是80，HTTPS协议端口是443

- HTTPS优点：

  - HTTPS传输数据过程中使用密钥进行加密，所以安全性更高
  - HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

- HTTPS缺点：

  - HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加

  - HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高



## Q8: http1.0和http1.1最大的区别?==长连接除了能够节省频繁握手挥手的开销还有什么优点?==

<!-- <img src="img/http0.png" alt="image-20200811152424993" style="zoom:50%;" /> -->
- 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

- 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

- 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。


## Q9: HTTP 和 HTTPs区别？

HTTPS和HTTP的区别主要如下：

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## Q10: TCP拥塞控制

拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。

1、慢开始

最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。

2、拥塞避免

每经过一个往返时间RTT，cwnd就增长1。

在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）

3、快重传

接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。

4、快恢复

当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。

采用慢开始和拥塞避免算法的时候

1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度

2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度

采用快恢复和快重传算法的时候

1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度

2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度



## Q11: 请问tcp握手为什么两次不可以？为什么不用四次？

两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常
不用四次：
本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：
1.客户端发送syn0给服务器
2.服务器收到syn0，回复ack(syn0+1)
3.服务器发送syn1
4.客户端收到syn1，回复ack(syn1+1)
因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。

---

dns劫持

怎样避免dns劫持

可以直接在客户端里写好dns server吗?

为什么DNS解析过程选择了并不可靠的UDP传输。

面对不同运营商例如电信移动, dns查询怎么优化找到对于用户来说比较快的ip(没听懂, 完全不会)

HTTP2.0的新特性？

TCP如何保证可靠传输？

http响应码，问了502



https的过程，怎么保证安全 

  \11. 为什么ssl层要采用对称密钥通信 

  \12. 对称密钥和非对称密钥的区别 

  \13. tcp/ip的每一层代表的是什么 

  \14. ARP的过程 

  \15. ip地址是虚拟ip吧，为什么客户端和服务端能通通信 

  \16. 传输层的最重要的协议 

  \17. tcp和udp的区别 

  \18. tcp服务端如果内存满了，客户端怎么处理

1.TCP什么情况下会分包？
TCP的滑动窗口机制
TCP确认机制

